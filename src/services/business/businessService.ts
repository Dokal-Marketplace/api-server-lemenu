// services/businessService.ts
import logger from '../../utils/logger';
import { Business, IBusiness } from '../../models/Business';
import { BusinessLocation, IBusinessLocation } from '../../models/BusinessLocation';

export interface CreateBusinessInput {
  // Core business fields
  name: string;
  description?: string;
  subDomain: string;
  domainLink: string;
  logo?: string;
  coverImage?: string;
  
  // Contact information
  phone: string;
  whatsapp: string;
  phoneCountryCode?: string;
  whatsappCountryCode?: string;
  
  // Business settings
  acceptsDelivery?: boolean;
  acceptsPickup?: boolean;
  acceptsOnlinePayment?: boolean;
  onlinePaymentOnly?: boolean;
  
  // Address information
  address: {
    street: string;
    city: string;
    state: string;
    zipCode: string;
    country: string;
    coordinates?: {
      latitude: number;
      longitude: number;
    };
  };
  
  // Owner information
  owner: {
    userId: string;
    name: string;
    email: string;
  };
  
  // Additional settings
  settings?: Partial<IBusiness['settings']>;
}

export interface CreateBusinessLocationInput {
  // Core location fields
  name: string;
  description?: string;
  phone: string;
  email?: string;
  
  // Address information
  address: {
    street: string;
    city: string;
    state: string;
    zipCode: string;
    country: string;
    coordinates?: {
      latitude: number;
      longitude: number;
    };
  };
  
  // Status
  status?: 'active' | 'inactive' | 'suspended';
  
  // Schedule (optional)
  schedule?: {
    [day: string]: Array<{
      start: string;
      end: string;
    }> | null;
  };
  
  // Delivery and mileage zones
  deliveryZones?: any[];
  mileageZones?: any[];
  
  // Location settings
  settings?: {
    allowDelivery?: boolean;
    allowPickup?: boolean;
    allowOnSite?: boolean;
    deliveryHours?: any;
    pickupHours?: any;
    onSiteHours?: any;
    kitchenCloseOffset?: number;
  };
  
  // Required references
  businessId: string;
  subDomain: string;
  
  // Optional
  isActive?: boolean;
}

export interface UpdateBusinessInput {
  // Core business fields
  name?: string;
  description?: string;
  logo?: string;
  coverImage?: string;
  
  // Contact information
  phone?: string;
  whatsapp?: string;
  phoneCountryCode?: string;
  whatsappCountryCode?: string;
  
  // Business settings
  acceptsDelivery?: boolean;
  acceptsPickup?: boolean;
  acceptsOnlinePayment?: boolean;
  onlinePaymentOnly?: boolean;
  isOpenForDelivery?: boolean;
  isOpenForPickup?: boolean;
  isActive?: boolean;
  
  // Address information
  address?: Partial<IBusiness['address']>;
  
  // Status and settings
  status?: 'active' | 'inactive' | 'suspended';
  settings?: Partial<IBusiness['settings']>;
}

export interface BusinessQueryFilters {
  // Core identifiers
  userId?: string;
  subDomain?: string;
  businessId?: string;
  localId?: string;
  
  // Status filters
  isActive?: boolean;
  status?: 'active' | 'inactive' | 'suspended';
  
  // Location filters
  city?: string;
  state?: string;
  country?: string;
  
  // Service filters
  acceptsDelivery?: boolean;
  acceptsPickup?: boolean;
  
  // Search and pagination
  search?: string;
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export class BusinessService {
  /**
   * Create a new business
   */
  static async createBusiness(data: CreateBusinessInput): Promise<IBusiness> {
    try {
      logger.info(`Creating business with subdomain: ${data.subDomain}`, {
        subDomain: data.subDomain,
        name: data.name,
        ownerId: data.owner.userId
      });

      // Check if subdomain already exists
      const existingBusiness = await Business.findOne({
        subDomain: data.subDomain
      });

      if (existingBusiness) {
        logger.warn(`Subdomain already exists: ${data.subDomain}`);
        throw new Error('Subdomain already exists');
      }

      // Set default settings if not provided
      const defaultSettings = {
        currency: 'PEN' as const,
        timezone: 'America/Lima',
        taxRate: 18, // Default tax rate
        serviceCharge: 0,
        deliveryFee: 0,
        minOrderValue: 0,
        maxDeliveryDistance: 10,
        autoAcceptOrders: false,
        orderNotifications: true,
        paymentMethods: [
          {
            type: 'cash' as const,
            name: 'Cash',
            isActive: true
          }
        ],
        features: {
          delivery: data.acceptsDelivery ?? true,
          pickup: data.acceptsPickup ?? true,
          onSite: false,
          scheduling: false,
          coupons: false
        }
      };

      const businessData = {
        ...data,
        userId: data.owner.userId, // Add this line
        // businessId will be auto-generated by pre-save middleware
        phoneCountryCode: data.phoneCountryCode || '+51',
        whatsappCountryCode: data.whatsappCountryCode || '+51',
        acceptsDelivery: data.acceptsDelivery ?? true,
        acceptsPickup: data.acceptsPickup ?? true,
        acceptsOnlinePayment: data.acceptsOnlinePayment ?? true,
        onlinePaymentOnly: data.onlinePaymentOnly ?? false,
        isOpenForDelivery: true,
        isOpenForPickup: true,
        isActive: true,
        status: 'active' as const,
        settings: { ...defaultSettings, ...data.settings },
        locations: []
      };

      const business = new Business(businessData);
      await business.save();

      logger.info(`Business created successfully`, {
        businessId: business.businessId,
        subDomain: business.subDomain,
        name: business.name
      });

      return business;
    } catch (error: any) {
      logger.error('Error creating business', {
        error: error.message,
        subDomain: data.subDomain,
        ownerId: data.owner.userId,
        stack: error.stack
      });
      if (error.code === 11000) {
        const field = Object.keys(error.keyPattern)[0];
        throw new Error(`${field} already exists`);
      }
      throw error;
    }
  }

  /**
   * Create a new business location
   */
  static async createBusinessLocation(data: CreateBusinessLocationInput): Promise<IBusinessLocation> {
    try {
      logger.info(`Creating business location with name: ${data.name}`, {
        name: data.name,
        businessId: data.businessId,
        subDomain: data.subDomain
      });

      // Verify that the parent business exists
      const parentBusiness = await Business.findOne({ businessId: data.businessId });
      if (!parentBusiness) {
        logger.warn(`Parent business not found for businessId: ${data.businessId}`);
        throw new Error('Parent business not found');
      }

      // Set default settings if not provided
      const defaultSettings = {
        allowDelivery: true,
        allowPickup: true,
        allowOnSite: false,
        deliveryHours: {},
        pickupHours: {},
        onSiteHours: {},
        kitchenCloseOffset: 30
      };

      const locationData = {
        ...data,
        status: data.status || 'active',
        isActive: data.isActive !== undefined ? data.isActive : true,
        schedule: data.schedule || {},
        deliveryZones: data.deliveryZones || [],
        mileageZones: data.mileageZones || [],
        settings: { ...defaultSettings, ...data.settings }
      };

      const businessLocation = new BusinessLocation(locationData);
      await businessLocation.save();

      logger.info(`Business location created successfully`, {
        localId: businessLocation.localId,
        name: businessLocation.name,
        businessId: businessLocation.businessId
      });

      return businessLocation;
    } catch (error: any) {
      logger.error('Error creating business location', {
        error: error.message,
        name: data.name,
        businessId: data.businessId,
        subDomain: data.subDomain,
        stack: error.stack
      });
      if (error.code === 11000) {
        const field = Object.keys(error.keyPattern)[0];
        throw new Error(`${field} already exists`);
      }
      throw error;
    }
  }

  /**
   * Get a single business by various filters
   */
  static async getBusiness(filters: BusinessQueryFilters): Promise<IBusiness | null> {
    try {
      logger.info('Getting business with filters', { filters });

      // If localId is provided, find the BusinessLocation first, then get the parent Business
      if (filters.localId) {
        logger.debug(`Looking up business by localId: ${filters.localId}`);
        const businessLocation = await BusinessLocation.findOne({ localId: filters.localId });
        if (!businessLocation) {
          logger.warn(`BusinessLocation not found for localId: ${filters.localId}`);
          return null;
        }
        
        // Get the parent business using the businessId from the location
        const business = await Business.findOne({ businessId: businessLocation.businessId });
        if (business) {
          logger.info(`Business found by localId`, {
            businessId: business.businessId,
            localId: filters.localId
          });
        } else {
          logger.warn(`Business not found for businessId: ${businessLocation.businessId}`);
        }
        return business;
      }

      // For other queries, search Business model directly
      const query: any = {};

      if (filters.userId) query.userId = filters.userId;
      if (filters.subDomain) query.subDomain = filters.subDomain;
      if (filters.businessId) query.businessId = filters.businessId;
      if (filters.isActive !== undefined) query.isActive = filters.isActive;
      if (filters.status) query.status = filters.status;

      logger.debug('Executing business query', { query });
      const business = await Business.findOne(query);
      
      if (business) {
        logger.info('Business found', {
          businessId: business.businessId,
          subDomain: business.subDomain,
          name: business.name
        });
      } else {
        logger.info('No business found matching criteria', { query });
      }
      
      return business;
    } catch (error: any) {
      logger.error('Error getting business', {
        error: error.message,
        filters,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Get businesses by user id
   */
  static async getBusinessesByUserId(userId: string) {
    try {
      const businesses = await Business.find({ 'owner.userId': userId });
      return businesses;
    } catch (error: any) {
      logger.error('Error getting businesses by user id', { error: error.message, userId });
      throw error;
    }
  }

  /**
   * Get multiple businesses with pagination and filters
   */
  static async getBusinesses(filters: BusinessQueryFilters = {}) {
    try {
      const {
        page = 1,
        limit = 10,
        sortBy = 'createdAt',
        sortOrder = 'desc',
        search,
        ...queryFilters
      } = filters;

      logger.info('Getting businesses with filters', {
        filters: {
          page,
          limit,
          search,
          ...queryFilters
        }
      });

      const query: any = {};

      // Apply filters
      Object.keys(queryFilters).forEach(key => {
        if (queryFilters[key as keyof typeof queryFilters] !== undefined) {
          query[key] = queryFilters[key as keyof typeof queryFilters];
        }
      });

      // Add text search if provided
      if (search) {
        query.$text = { $search: search };
        logger.debug('Adding text search to query', { searchTerm: search });
      }

      // Calculate pagination
      const skip = (page - 1) * limit;
      const sortObj: any = {};
      sortObj[sortBy] = sortOrder === 'desc' ? -1 : 1;

      // Execute query
      // Build base query
      let findQuery = Business.find(query);

      // If doing text search and sorting by score, include text score meta
      if (search && sortBy === 'score') {
        findQuery = findQuery.select({ score: { $meta: 'textScore' } })
          .sort({ score: { $meta: 'textScore' } });
      } else {
        findQuery = findQuery.sort(sortObj);
      }

      // Apply pagination
      findQuery = findQuery.skip(skip).limit(limit);

      const [businesses, total] = await Promise.all([
        findQuery.exec(),
        Business.countDocuments(query)
      ]);

      logger.info('Businesses query completed', {
        totalFound: businesses.length,
        totalCount: total,
        page,
        limit,
        hasSearch: !!search
      });

      return {
        businesses,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit),
          hasNext: page < Math.ceil(total / limit),
          hasPrev: page > 1
        }
      };
    } catch (error: any) {
      logger.error('Error getting businesses', {
        error: error.message,
        filters,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Get businesses by owner/user
   */
  static async getBusinessesByOwner(userId: string, options: { page?: number; limit?: number } = {}) {
    try {
      logger.info('Getting businesses by owner', { userId, options });
      const { page = 1, limit = 10 } = options;
      
      const result = await this.getBusinesses({
        userId,
        page,
        limit,
        sortBy: 'createdAt',
        sortOrder: 'desc'
      });

      logger.info('Businesses by owner retrieved', {
        userId,
        businessCount: result.businesses.length,
        totalCount: result.pagination.total
      });

      return result;
    } catch (error: any) {
      logger.error('Error getting businesses by owner', {
        error: error.message,
        userId,
        options,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Get business locals (legacy method name)
   */
  static async getBusinessLocal(filters: BusinessQueryFilters): Promise<IBusiness[]> {
    try {
      logger.info('Getting business locals with filters', { filters });
      const query: any = {};

      // Use new address structure for location filtering
      if (filters.city) query['address.city'] = filters.city;
      if (filters.state) query['address.state'] = filters.state;
      if (filters.country) query['address.country'] = filters.country;
      
      if (filters.acceptsDelivery !== undefined) query.acceptsDelivery = filters.acceptsDelivery;
      if (filters.acceptsPickup !== undefined) query.acceptsPickup = filters.acceptsPickup;
      if (filters.isActive !== undefined) query.isActive = filters.isActive;

      logger.debug('Executing business local query', { query });
      const businesses = await Business.find(query).lean();
      
      logger.info('Business locals retrieved', {
        count: businesses.length,
        filters
      });
      
      return businesses as IBusiness[];
    } catch (error: any) {
      logger.error('Error getting business locals', {
        error: error.message,
        filters,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Update business
   */
  static async updateBusiness(
    identifier: string,
    updates: UpdateBusinessInput,
    identifierType: 'id' | 'subDomain' | 'businessId' | 'localId' = 'id'
  ): Promise<IBusiness | null> {
    try {
      logger.info('Updating business', {
        identifier,
        identifierType,
        updateFields: Object.keys(updates)
      });

      let query: any = {};
      
      // If localId is provided, find the BusinessLocation first to get the parent businessId
      if (identifierType === 'localId') {
        logger.debug(`Looking up business by localId: ${identifier}`);
        const businessLocation = await BusinessLocation.findOne({ localId: identifier });
        if (!businessLocation) {
          logger.warn(`BusinessLocation not found for localId: ${identifier}`);
          return null;
        }
        query.businessId = businessLocation.businessId;
        logger.debug(`Found businessId: ${businessLocation.businessId} for localId: ${identifier}`);
      } else {
        // For other identifier types, build query normally
        switch (identifierType) {
          case 'subDomain':
            query.subDomain = identifier;
            break;
          case 'businessId':
            query.businessId = identifier;
            break;
          default:
            query._id = identifier;
        }
      }

      // Handle nested updates for address and settings
      const updateData: any = { ...updates };
      
      if (updates.address) {
        Object.keys(updates.address).forEach(key => {
          updateData[`address.${key}`] = updates.address![key as keyof typeof updates.address];
        });
        delete updateData.address;
      }

      if (updates.settings) {
        Object.keys(updates.settings).forEach(key => {
          updateData[`settings.${key}`] = updates.settings![key as keyof typeof updates.settings];
        });
        delete updateData.settings;
      }

      logger.debug('Executing business update', { query, updateData });
      const business = await Business.findOneAndUpdate(
        query,
        { $set: updateData },
        { new: true, runValidators: true }
      );

      if (business) {
        logger.info('Business updated successfully', {
          businessId: business.businessId,
          subDomain: business.subDomain,
          updatedFields: Object.keys(updates)
        });
      } else {
        logger.warn('No business found to update', { query });
      }

      return business;
    } catch (error: any) {
      logger.error('Error updating business', {
        error: error.message,
        identifier,
        identifierType,
        updateFields: Object.keys(updates),
        stack: error.stack
      });
      if (error.code === 11000) {
        const field = Object.keys(error.keyPattern)[0];
        throw new Error(`${field} already exists`);
      }
      throw error;
    }
  }

  /**
   * Create a new local (legacy method name - now creates BusinessLocation)
   */
  static async createLocal(data: CreateBusinessLocationInput): Promise<IBusinessLocation> {
    return await this.createBusinessLocation(data);
  }

  /**
   * Delete business (soft delete by setting isActive to false)
   */
  static async deleteBusiness(
    identifier: string,
    identifierType: 'id' | 'subDomain' | 'businessId' | 'localId' = 'id'
  ): Promise<IBusiness | null> {
    try {
      logger.info('Deleting business (soft delete)', {
        identifier,
        identifierType
      });
      
      const result = await this.updateBusiness(identifier, { isActive: false, status: 'inactive' }, identifierType);
      
      if (result) {
        logger.info('Business deleted successfully', {
          businessId: result.businessId,
          subDomain: result.subDomain
        });
      } else {
        logger.warn('Business not found for deletion', {
          identifier,
          identifierType
        });
      }
      
      return result;
    } catch (error: any) {
      logger.error('Error deleting business', {
        error: error.message,
        identifier,
        identifierType,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Toggle business status (open/closed for delivery/pickup)
   */
  static async toggleBusinessStatus(
    identifier: string,
    status: {
      isActive?: boolean;
      status?: 'active' | 'inactive' | 'suspended';
    },
    identifierType: 'id' | 'subDomain' | 'businessId' | 'localId' = 'id'
  ): Promise<IBusiness | null> {
    try {
      logger.info('Toggling business status', {
        identifier,
        identifierType,
        newStatus: status
      });
      
      const result = await this.updateBusiness(identifier, status, identifierType);
      
      if (result) {
        logger.info('Business status toggled successfully', {
          businessId: result.businessId,
          isActive: result.isActive
        });
      }
      
      return result;
    } catch (error: any) {
      logger.error('Error toggling business status', {
        error: error.message,
        identifier,
        identifierType,
        status,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Search businesses by text
   */
  static async searchBusinesses(searchTerm: string, options: { page?: number; limit?: number } = {}) {
    try {
      logger.info('Searching businesses', {
        searchTerm,
        options
      });
      
      const { page = 1, limit = 10 } = options;
      
      const result = await this.getBusinesses({
        search: searchTerm,
        page,
        limit,
        sortBy: 'score',
        sortOrder: 'desc'
      });

      logger.info('Business search completed', {
        searchTerm,
        resultsFound: result.businesses.length,
        totalCount: result.pagination.total
      });
      
      return result;
    } catch (error: any) {
      logger.error('Error searching businesses', {
        error: error.message,
        searchTerm,
        options,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Get businesses by location
   */
  static async getBusinessesByLocation(
    city?: string,
    state?: string,
    country?: string,
    options: { page?: number; limit?: number } = {}
  ) {
    try {
      logger.info('Getting businesses by location', {
        city,
        state,
        country,
        options
      });
      
      const filters: BusinessQueryFilters = {
        isActive: true,
        status: 'active',
        ...options
      };

      if (city) filters.city = city;
      if (state) filters.state = state;
      if (country) filters.country = country;

      const result = await this.getBusinesses(filters);
      
      logger.info('Businesses by location retrieved', {
        city,
        state,
        country,
        resultsFound: result.businesses.length,
        totalCount: result.pagination.total
      });
      
      return result;
    } catch (error: any) {
      logger.error('Error getting businesses by location', {
        error: error.message,
        city,
        state,
        country,
        options,
        stack: error.stack
      });
      throw error;
    }
  }

  /**
   * Validate business location data
   */
  static validateBusinessLocationData(data: Partial<CreateBusinessLocationInput>): { isValid: boolean; errors: string[] } {
    logger.debug('Validating business location data', {
      hasName: !!data.name,
      hasBusinessId: !!data.businessId,
      hasSubDomain: !!data.subDomain,
      hasAddress: !!data.address
    });
    
    const errors: string[] = [];

    // Required field validations
    if (!data.name) errors.push('name is required');
    if (!data.phone) errors.push('phone is required');
    if (!data.businessId) errors.push('businessId is required');
    if (!data.subDomain) errors.push('subDomain is required');
    if (!data.address) errors.push('address is required');
    if (!data.address?.street) errors.push('address.street is required');
    if (!data.address?.city) errors.push('address.city is required');
    if (!data.address?.state) errors.push('address.state is required');
    if (!data.address?.zipCode) errors.push('address.zipCode is required');
    if (!data.address?.country) errors.push('address.country is required');

    // Format validations
    if (data.subDomain && !/^[a-z0-9-]+$/.test(data.subDomain)) {
      errors.push('subDomain can only contain lowercase letters, numbers, and hyphens');
    }

    // Phone number validations
    if (data.phone && !/^[\+]?[0-9\s\-\(\)]{7,15}$/.test(data.phone)) {
      errors.push('Invalid phone number format');
    }

    // Email validation
    if (data.email && !/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/.test(data.email)) {
      errors.push('Invalid email format');
    }

    // Status validation
    if (data.status && !['active', 'inactive', 'suspended'].includes(data.status)) {
      errors.push('Status must be active, inactive, or suspended');
    }

    // Kitchen close offset validation
    if (data.settings?.kitchenCloseOffset !== undefined && data.settings.kitchenCloseOffset < 0) {
      errors.push('Kitchen close offset must be a non-negative number');
    }

    const result = {
      isValid: errors.length === 0,
      errors
    };
    
    if (result.isValid) {
      logger.debug('Business location data validation passed');
    } else {
      logger.warn('Business location data validation failed', {
        errorCount: errors.length,
        errors
      });
    }
    
    return result;
  }

  /**
   * Validate business data
   */
  static validateBusinessData(data: Partial<CreateBusinessInput>): { isValid: boolean; errors: string[] } {
    logger.debug('Validating business data', {
      hasName: !!data.name,
      hasSubDomain: !!data.subDomain,
      hasOwner: !!data.owner,
      hasAddress: !!data.address
    });
    
    const errors: string[] = [];

    // Required field validations
    if (!data.name) errors.push('name is required');
    if (!data.subDomain) errors.push('subDomain is required');
    if (!data.domainLink) errors.push('domainLink is required');
    if (!data.phone) errors.push('phone is required');
    if (!data.whatsapp) errors.push('whatsapp is required');
    if (!data.owner) errors.push('owner is required');
    if (!data.owner?.userId) errors.push('owner.userId is required');
    if (!data.owner?.name) errors.push('owner.name is required');
    if (!data.owner?.email) errors.push('owner.email is required');
    if (!data.address) errors.push('address is required');
    if (!data.address?.street) errors.push('address.street is required');
    if (!data.address?.city) errors.push('address.city is required');
    if (!data.address?.state) errors.push('address.state is required');
    if (!data.address?.country) errors.push('address.country is required');

    // Format validations
    if (data.subDomain && !/^[a-z0-9-]+$/.test(data.subDomain)) {
      errors.push('subDomain can only contain lowercase letters, numbers, and hyphens');
    }

    if (data.domainLink && !/^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(data.domainLink)) {
      errors.push('Invalid domain format');
    }

    // Phone number validations
    if (data.phone && !/^[\+]?[0-9\s\-\(\)]{7,20}$/.test(data.phone)) {
      errors.push('Invalid phone number format');
    }

    if (data.whatsapp && !/^[\+]?[0-9\s\-\(\)]{7,20}$/.test(data.whatsapp)) {
      errors.push('Invalid WhatsApp number format');
    }

    // Country code validations
    if (data.phoneCountryCode && !/^\+[0-9]{1,4}$/.test(data.phoneCountryCode)) {
      errors.push('Invalid phone country code format');
    }

    if (data.whatsappCountryCode && !/^\+[0-9]{1,4}$/.test(data.whatsappCountryCode)) {
      errors.push('Invalid WhatsApp country code format');
    }

    // Email validation
    if (data.owner?.email && !/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/.test(data.owner.email)) {
      errors.push('Invalid email format');
    }

    // Tax rate validation (now handled in settings.taxRate)
    if (data.settings?.taxRate !== undefined && (data.settings.taxRate < 0 || data.settings.taxRate > 100)) {
      errors.push('Tax rate must be between 0 and 100');
    }

    const result = {
      isValid: errors.length === 0,
      errors
    };
    
    if (result.isValid) {
      logger.debug('Business data validation passed');
    } else {
      logger.warn('Business data validation failed', {
        errorCount: errors.length,
        errors
      });
    }
    
    return result;
  }
}
